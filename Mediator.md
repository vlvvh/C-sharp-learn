# 中介者模式 （ Mediator pattern ）
中介者模式在现实生活中有很多例子，比如：A 和 B 做生意，A 或 B 的想法会经常变化，每次改变时告诉对方，会使对方很反感。如果在 A 和 B 之间增加一个 C 对象，在最终确定之前不要告诉 C 对象，对方就不知道了（隔离了耦合，对方可以更具需求变化），
等一方最终确定想法后，把最后决定告诉 C 对象，C 再转告给对方。这样就简化了 A 和 B 的交易过程，而且双方都很满意。       

在软件构建过程中，因为有了变化，才有增加中介者的需要 ‼️       
变化是模式的前提，无论是什么模式，就因为有变化，我们需要抵御变化，才要使用相应的模式解决问题。   

## 一、模式的详细介绍      
### 1.1 动机
在软件构建过程中，经常会出现多个对象互相关联交互的情况，对象之间常常会维持一种复杂的引用关系，如果遇到一些需求的更改，这种直接的引用关系将面临不断变化。          
在这种情况下，我们可以**使用一个“中介对象”来管理对象间的关联关系，避免相互交互的对象之间的紧耦合引用关系，从而更好的抵御变化。**

### 1.2 意图
定义了一个中介对象来封装一系列对象之间的交互关系。中介者使各个对象之间不需要显式地相互引用，从而使耦合性降低，而且可以独立地改变他们之间的交互行为。   

### 1.3 结构图
![image](https://github.com/vlvvh/C-sharp-learn/assets/160467935/5c3e6f56-b7da-4985-935e-086dce492790)

### 1.4 模式的组成
( 1 ) 抽象中介者角色 ( Mediator ):在这里定义了各个对象之间交互需要的方法。可以是公众的通信方法，也可以是小范围的交互方法。 

( 2 ) 具体中介者角色 ( ConcreteMediator ):实现了中介者接口，它需要了解并维护各个同事对象，并负责具体的协调各同事对象之间的交互关系。

( 3 ) 抽象同事类( Colleague ): 定义了一个接口或抽象类，通常为抽象类，主要约束同事对象的类型，并实现一些具体同事类之间的公共功能   

      比如:每个具体同事类都应该知道中介者对象，也就是具体同事类都会持有中介者对象，都可以到这个类里面。 

( 4 ) 具体同事类( ConcreteConlleague ):实现自己的业务，**需要与其他同事通信时候，就与持有的中介者通信，中介者会负责与其他同事类交互**

### 1.5 模式的具体实现
#### 举个例子🌰：
在公司管理过程中，就会涉及到各个部门之间的协调和合作，沟通协调就需要一个人来做，假设是总经理，把总经理定义为管理者，各个部门需要向他汇报和发起工作请求。代码如下：
~~~

~~~
